<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>陣列</title>
</head>

<body>
  <script>
    //變數命名方式：參考'駝峰式命名'，要可以讓人看懂!!!
    let userName = 'Loki'; //val of str，一個值 
    let userAge = 12; //val of num，一個值

    let myAryAA = new Array(); //正式宣告，透過內建建構式(產生一個大型物件，裡面包含一些原生的prototype)來完成，一般人偷懶不會用這個
    let myAryAB = []; //空陣列的語法糖果，暴力指定變數
    let myAryAC = new Array(1, 2, 'A', true);


    let myAryB = ['A', true, 3]; //value of array,可以指定n個值，每個值有自己的index值(索引,可看成火車的第0,1,2,3...節車廂)

    //===============================
    //myAryB = ['B', true, 3];
    //對應index值 [0 ,  1   , 2];
    //**index值的起始號碼為'0'

    //myAryB[0]=100，透過指定陣列的'索引值'，可以改變陣列的其中一個值

    //根據push pop shift unshift來操作陣列增減長度與內容
    //↑工作上不太這樣用，因為會有記憶體汙染的問題↑

    let aryInit = [1, 2, 3]; //預設值
    let errCloneAry = aryInit; //預設ary，因為指定，所以兩者存取的記憶體位置完全一樣，這叫記憶體汙染

    let realCloneAry = [...aryInit];//ES6解構與重構，將陣列解開，重新組合陣列並指定給b

    let a = [1, 2, 3];//被複製的固定陣列
    let b = [...a];//重構出一個乾淨的陣列，指定給b
    b.push('A');
    console.log(b);//b與a式不同的陣列，他們的記憶體位置不同

    let c = [...a, 'C'];
    let d = [...a, 'hello', ...b];

    console.log(d);
    console.clear();

    // a.push('C'); 老師工作上不會用這個寫法
    a = ['A', ...a, 'C'];

    //////////////////////////////////////

    function hello() {
      console.log('hello');
    }

    let minAry = ['A', 'B', 'C'];

    //bigAry=[hello,minAry];  
    let bigAry = [
      ['A', 'B', 'C'],
      hello,
      minAry
    ];//巢狀array,二維陣列

    //let ary

    const ary2=[1,2,3]; //保護變數有無重新指定(記憶體改變)
    ary2.push('A');





  </script>
</body>

</html>